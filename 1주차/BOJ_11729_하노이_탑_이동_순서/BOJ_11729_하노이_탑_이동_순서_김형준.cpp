//
// BOJ - 11729
// 하노이 탑 이동 순서
//
// 난이도: S1
// 제출자: wasuphj @Github
// 

#include <iostream>
using namespace std;

int N, K = 0;

void rec(int n, int start, int mid, int end) {
	if (n == 1) {
		cout << start << " " << end << "\n"; // 고리가 1개라면 중간 지점 없이 즉시 이동 가능
		return;
	}

	rec(n - 1, start, end, mid); // N-1개의 고리를 시작 지점에서 중간 지점으로 이동
	rec(1, start, mid, end); // 1개의 고리를 시작 지점에서 종료 지점으로 이동
	rec(n - 1, mid, start, end); // N-1개의 고리를 중간 지점에서 종료 지점으로 이동
}

int main() {
	// 표준 입력 속도 증가 코드
	cin.tie(NULL);
	ios::sync_with_stdio(false);

	cin >> N;

	K = (1 << N) - 1; // 하노이 탑의 최소 이동 횟수는 2^N - 1
	cout << K << "\n";

	rec(N, 1, 2, 3); // 하노이 탑 재귀 탐색 시작

	return 0;
}

//
// 코멘트:
//
// 백트래킹인가? 이걸 어떻게 재귀로 하지... 하고 한참을 보다가
// 검색해보니 하노이탑의 성질과 알고리즘이 있었다
// 
// 먼저 하노이 탑의 최소 이동 횟수는 2^N - 1
//
// 하노이 탑의 재귀 해법 알고리즘은
// 1. N - 1개의 링을 1번에서 2번으로 옮긴다
// 2. 1개의 링(시작시 제일 밑의 링)을 1번에서 3번으로 옮긴다
// 3. N - 1개의 링을 2번에서 3번으로 옮긴다
// 
// 이걸 어떻게 하지 했는데 그냥 재귀 코드로 돌리니 알아서 돌아간다
//
// 신기하다
//
// 순수 재귀로 하노이의 탑을 풀 수 있구나
//
